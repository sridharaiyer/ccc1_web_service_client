HTTP/1.1 200 OK
Content-Type: application/x-javascript
Content-Length: 36818
Connection: keep-alive
Date: Tue, 01 Nov 2016 17:41:25 GMT
Last-Modified: Wed, 22 Oct 2014 21:02:24 GMT
ETag: "30dadf0a8de86d918a8dfcdc9d339f5c"
Content-Encoding: UTF-8
Accept-Ranges: bytes
Server: AmazonS3
Age: 83685
X-Cache: Hit from cloudfront
Via: 1.1 0459f84cfc86cb6f46c44cb1d0a8bdc0.cloudfront.net (CloudFront)
X-Amz-Cf-Id: 4-oqqR9q2SPH0DF-gjq2f139XDvq2N6hBHUF_X-Jd53DHX-g50RRww==

/*
*--------------------------------------------------------------------------------------------------------------------------------------------
* The glider slider will take a group of inventory items and place them into a container.													*
* This slider will clone containers so it can animate them at a given pixel per frame rate.													*
* This slider pulls some display parameters from arrays that are passed in for both the containers and the arrows.							*
* This slider also takes care of different click and hover events.																			*
* Has feature for cloning cells or centering if not enough cells exists.                                                                    *
*============================================================================================================================================
* sliderWidth          		(@Number)  = The width of the slider.                                                                   		*
* sliderHeight             	(@Number)  = The height of the slider.                                                              			*
* cellPadding             	(@Number)  = The padding between each cell and container.                                             		    *
* items             		(@Array)   = An array of cells.                                                              					*
* prevArrow      			(@Object)  = The prev arrow.                                                               						*
* nextArrow             	(@Object)  = The next arrow.                                                                                  	*
* arrowPositions            (@Array)   = The IN position of the arrows.                                                   			        *
* autoScrollRate          	(@Number)  = The number of pixels to scroll by during auto scroll.                                             	*
* hoverScrollRate          	(@Number)  = The number of pixels to scroll by during arrow hover.                                              *
* clone  					(@Boolean) = Whether the cells should clone if there are not enough to fill the slider.                         *
* horizontal         		(@Boolean) = Whether the slider is horizontal.                                                  				*
* startCentered    			(@Boolean) = Whether the first inventory item should start centered.                                            *
* autoScrollForce      		(@Boolean) = Whether the scroller should adhere to the FlashVars animationDelay. 			                    *
* autoScrollMousePause   	(@Boolean) = Whether autoscrolling should pause when the mouse is over the stage. 		                        *
*******************************************************<== NOTES ==>*************************************************************************
* @author                  Chris Brenner
* @date                    Feb 20th 2014
* @version                 1.0

* @modify_by               Chris Brenner
* @modify_date             Feb 20th 2014
*--------------------------------------------------------------------------------------------------------------------------------------------
*/

// The slider object.
var _gsSlider;

// The user defined width and height of the slider.
var _gsSliderWidth;
var _gsSliderHeight;

// The width and height of each cell container.
var _gsSingleContainerWidth;
var _gsSingleContainerHeight;

// The combined width and height of the cell containers.
var _gsAllContainersWidth;
var _gsAllContainersHeight;

// The distance between each cell/container.
var _gsCellPadding;

// The two sprites that are directly added to this and the components are added to.
var _gsCellLevel;
var _gsArrowLevel;

// The arrays that define the parameters of the components for different stages.
var _gsPositions
var _gsOutPositions = null;
var _gsArrowPositions;
var _gsArrowOutPositions;

// The components that are placed in this Sprite. The cells and the arrows.
var _gsItemsArray; 				// Array holding initial cells.
var _gsCells; 					// Multidimensional array holding initial and cloned cells.
var _gsCellContainerArray; 		// Array holding all of the cell containers.
var _gsPrevArrow;
var _gsNextArrow;

// The rate at which the glider will scroll.
var _gsAutoScrollRate;
var _gsHoverScrollRate

// Variables used to operate the cell's auto scrolling.
var _gsAutoScroll;
var _gsStartUnit = 0;
var _gsEndUnit;
var _gsScrollState = "auto";

// Used to check if the scroller is being manually scrolled.
var _gsScrolling = '';

// The number of inventory items.
var _gsNumItems;

// Whether the slider will animate or not.
var _gsAnimate;

// Whether cloning will occur if the cells don't fill the slider.
var _gsClone;

// Whether the gliding will be horizontal or vertical.
var _gsHorizontal;

// Whether the first cell should start centered within the slider.
var _gsStartCentered;

// Whether the scroller should adhere to the FlashVars animationDelay.
var _gsAutoScrollForce;

// Whether autoscrolling should pause when the mouse is over the stage.
var _gsAutoScrollMousePause;

// The easing used to animate the container in.
var _gsContainerAnimateInEasing;

//The frame per second of the animation. Set to 18 to match current flash standard.
//Used to dictate how frequently the animation should 'tick'.
var _gsFps = 18;

function gSlider(sliderWidth,
			 	sliderHeight,
			 	cellPadding,
			 	items,
				prevArrow,
				nextArrow,
				arrowPositions,
				autoScrollRate,
				hoverScrollRate,
				clone,
				horizontal,
				startCentered,
				autoScrollForce,
				autoScrollMousePause) {

	_gsSlider = this;

	// Save needed values as properties so it will be possible to use them throughout this object.
	_gsSliderWidth 					= sliderWidth;
	_gsSliderHeight 				= sliderHeight;
	_gsCellPadding					= cellPadding;

	_gsItemsArray 					= items;
	_gsNumItems						= items.length;

	_gsPrevArrow					= prevArrow;
	_gsNextArrow					= nextArrow;
	_gsArrowPositions				= arrowPositions;

	_gsAutoScrollRate				= autoScrollRate;
	_gsHoverScrollRate				= hoverScrollRate;

	_gsClone						= clone
	_gsHorizontal					= horizontal;

	_gsStartCentered				= startCentered;

	_gsAutoScrollForce				= autoScrollForce;
	_gsAutoScrollMousePause			= autoScrollMousePause;


	// Create main scroller container and set attributes and styles.
	var Scroller = document.createElement('div');
	id('ssm_ad_container').appendChild(Scroller);
	Scroller.setAttribute('id', 'scroller');
	Scroller.setAttribute('class', 'scroller');

	superStyle(Scroller, {
		width: 			sliderWidth,
		height: 		sliderHeight,
		position: 		'absolute',
		overflow:   	'hidden'
	});


	// Create containers to hold the cell containers and arrows.
	_gsCellLevel = document.createElement('div');
	Scroller.appendChild(_gsCellLevel);
	_gsCellLevel.setAttribute('id', 'cellLevel');

	_gsArrowLevel = document.createElement('div');
	Scroller.appendChild(_gsArrowLevel);
	_gsArrowLevel.setAttribute('id', 'arrowLevel');


	// Get variables needed for positioning and sizing.
	var cellWidth;
	var cellHeight;

	// Checks if there is a border on the cell or not.
	if (items[0].dom.style.borderLeftWidth == ''){
		cellWidth 	= parseInt(items[0].dom.style.width);
		cellHeight 	= parseInt(items[0].dom.style.height);
	}
	else {
		cellWidth 	= parseInt(items[0].dom.style.width) + parseInt(items[0].dom.style.borderLeftWidth) + parseInt(items[0].dom.style.borderRightWidth);
		cellHeight 	= parseInt(items[0].dom.style.height) + parseInt(items[0].dom.style.borderTopWidth) + parseInt(items[0].dom.style.borderBottomWidth);
	}

	_gsSingleContainerWidth		= horizontal ? (cellWidth * _gsNumItems) + (cellPadding * (_gsNumItems - 1)) : cellWidth;
	_gsSingleContainerHeight	= horizontal ? cellHeight : (cellHeight * _gsNumItems) + (cellPadding * (_gsNumItems - 1));


	// SET UP CLONING.
	// If animating, containers must fill slider space and have 1 extra container that can move positions.
	var cloneBy = 1; // Total number of containers needed initially.
	var smallSize; 	// Is it smaller than the slider space?

	smallSize = horizontal ? _gsSingleContainerWidth < sliderWidth : _gsSingleContainerHeight < sliderHeight;

	if (!clone) {
		if (smallSize) {
			// Container will be smaller than slider. Will not clone. Will not animate. Copy initial itemsArray.
			_gsAnimate 		= false;
			_gsCells 		= items;
		}
		else {
			// Container will be larger than slider. WIll clone so it can animate. Create multidimensional array.
			cloneBy 		= 2;
			_gsAnimate 		= true;

			this.createCloneItems(cloneBy);
		}
	}
	else {
		if (smallSize) {
			// Container will be smaller than slider. Will clone. Will animate. Create multidimensional array.
			// Find out how many times to clone by to fill slider.
			var initialContainerSize	= horizontal ? _gsSingleContainerWidth : _gsSingleContainerHeight
			var minimumContainerSize 	= horizontal ? sliderWidth : sliderHeight;
			var totalContainersSize 	= horizontal ? _gsSingleContainerWidth : _gsSingleContainerHeight;

			// Keep making additional containers until they are bigger than the slider space.
			while (totalContainersSize <= minimumContainerSize) {
				totalContainersSize += initialContainerSize + cellPadding;
				cloneBy++;
			}

			cloneBy++; // Add 1 more clone.
			_gsAnimate 		= true;

			// Clone aditional containers.
			this.createCloneItems(cloneBy);
		}
		else {
			// Container will be larger than slider. Will clone. Will animate. Create multidimensional array.
			cloneBy 		= 2;
			_gsAnimate 		= true;

			// Clone another container.
			this.createCloneItems(cloneBy);
		}
	}

	// Set the width and height of all the containers combined. Used for container positioning while scrolling occurs.
	_gsAllContainersWidth 	= horizontal ? (_gsSingleContainerWidth * cloneBy) + (cellPadding * (cloneBy -1)) : _gsSingleContainerWidth;
	_gsAllContainersHeight 	= horizontal ? _gsSingleContainerHeight : (_gsSingleContainerHeight * cloneBy) + (cellPadding * (cloneBy - 1));

	// Set height and width on cellLevel.
	var cellLevelWidth 		= horizontal ? _gsSliderWidth : _gsAllContainersWidth;
	var cellLevelHeight 	= horizontal ? _gsAllContainersHeight : _gsSliderHeight;

	superStyle(_gsCellLevel, {
		height: 			cellLevelHeight + 'px',
		width: 				cellLevelWidth + 'px',
		zIndex: 			0
	});


	// SET UP CONTAINERS.
	// Each container will have a full set of inventory items.
	_gsCellContainerArray = new Array();
	_gsPositions = [];

	// Position of first container relative to scroller container.
	// The distance the container is being moved to center it.
	var containerOffset	= _gsHorizontal ? (_gsSliderWidth - cellWidth) / 2 : (_gsSliderHeight - cellHeight) / 2;

	// The number of container lengths, rounded up, that will fit in the offset space.
	var offsetDifference = _gsHorizontal ? Math.ceil(containerOffset / _gsSingleContainerWidth) : Math.ceil(containerOffset / _gsSingleContainerHeight);

	// Will either be left aligned or have the first cell centered within the slider.
	// If the cell should be centered, the first container will be moved up/left as far as necessary to permit it to still be the first container on the stage but allow one of it's siblings to have it's first cell in center position. This ensures that the first container created will always be the upper/left most container in the beginning.
	var containerX 	= (_gsStartCentered && _gsHorizontal && _gsAnimate) ? containerOffset - (_gsSingleContainerWidth * offsetDifference) - (_gsCellPadding * offsetDifference) : 0;
	var containerY 	= (_gsStartCentered && !_gsHorizontal && _gsAnimate) ? containerOffset - (_gsSingleContainerHeight * offsetDifference) - (_gsCellPadding * offsetDifference) : 0;


	// Populate each container with a full set of inventory items and position everything.
	for (var i = 0; i < cloneBy; i++) {
		// Create container to hold the initial full set of cells.
		var cellContainer = document.createElement('div');
		cellContainer.setAttribute('id', 'container' + i);
		_gsCellLevel.appendChild(cellContainer);

		// Position of first cell relative to cellContainer.
		var cellX 	= 0;
		var cellY 	= 0;

		// Get individual cell.
		for (var k = 0; k < _gsNumItems; k++) {
			var cell;
			if(!_gsClone && smallSize) {
				cell = _gsCells[k].dom;
			}
			else {
				cell = _gsCells[k][i].dom;
			}

			// Add each cell to cellContainer.
			cellContainer.appendChild(cell);

			// Add cells in a row / column sequentially.
			superStyle(cell, {
				position: 		'absolute',
				top: 			horizontal ? 0 : cellY,
				left: 			horizontal ? cellX : 0
			});

			cellX 	= horizontal ? cellX + cellWidth + cellPadding : 0;
			cellY 	= horizontal ? 0 : cellY + cellHeight + cellPadding;
		}

		// The top and left positions of each container.
		var containerTop 	= horizontal ? (cellLevelHeight - _gsSingleContainerHeight) / 2 : containerY;
		var containerLeft 	= horizontal ? containerX : (cellLevelWidth - _gsSingleContainerWidth) / 2;

		// Positions containers in a row / column sequentially.
		superStyle(cellContainer, {
			position: 		'absolute',
			top: 			containerTop,
			left: 			containerLeft,
			width: 			_gsSingleContainerWidth,
			height: 		_gsSingleContainerHeight,
			opacity: 		1
		});

		// Create an array of in positions for each cell container.
		_gsPositions.push({left: containerLeft + 'px', top: containerTop + 'px', opacity: cellContainer.style.opacity});

		// Calculate the new x and y positions.
		containerX 	= horizontal ? containerX + _gsSingleContainerWidth + cellPadding : 0;
		containerY 	= horizontal ? 0 : containerY + _gsSingleContainerHeight + cellPadding;

		// Hide each container initially.
		cellContainer.style.visibility = 'hidden';

		// Add each cellContainer to cellLevel.
		_gsCellLevel.appendChild(cellContainer);

		// Push each container to an array that will be used for positioning.
		_gsCellContainerArray.push(cellContainer);
	}

	// Find out which container is the end container. Used for positioning during scrolling.
	_gsEndUnit = _gsCellContainerArray.length - 1;

	// If the cellLevel is smaller than the slider (meaning cloning is turned off), center it inside the slider.
	// Otherwise center only vertically or horizontally based on orientation.
	if (!_gsClone && smallSize) {
		superStyle(_gsCellLevel, {
			height: 		_gsSingleContainerHeight + 'px',
			width: 			_gsSingleContainerWidth + 'px'
		});

		centerDiv(_gsCellLevel);
	}
	else {
		superStyle(_gsCellLevel, {
			position: 		'absolute',
			top: 			horizontal ? (sliderHeight - parseInt(_gsCellLevel.style.height)) / 2 : 0,
			left: 			horizontal ? 0 : (sliderWidth - parseInt(_gsCellLevel.style.width)) / 2,
			overflow: 		'hidden'
		});
	}


	// SET UP ARROWS.
	// Only need arrows if animating will occur.
	if (_gsAnimate) {
		// Set zIndex.
		superStyle(_gsArrowLevel, {
			zIndex: 		1
		});

		// Hide the arrows initially.
		_gsPrevArrow.dom.style.visibility	= 'hidden';
		_gsNextArrow.dom.style.visibility	= 'hidden';

		// Sets all the properties for the PREVIOUS arrow to their IN state.
		for (var prevProp in _gsArrowPositions[0]) {
			_gsPrevArrow.dom.style[prevProp] = _gsArrowPositions[0][prevProp];
		}

		// Sets all the properties for the NEXT arrow to their IN state.
		for (var nextProp in _gsArrowPositions[1]) {
			_gsNextArrow.dom.style[nextProp] = _gsArrowPositions[1][nextProp];
		}

		// Adds the arrows to the stage.
		_gsArrowLevel.appendChild(_gsPrevArrow.dom);
		_gsArrowLevel.appendChild(_gsNextArrow.dom);
	}
}

/**
 * This function reconstructs the _items array into a 2D array where each index
 * will contain an array of cloned items depending of the number of containers requested.
 *
 * @param numClones 	The number of containers needed, each with a full set of cells.
 */
gSlider.prototype.createCloneItems = function(numClones) {
	_gsCells = new Array();

	var tempArray;

	//For each cell, clone one for every container.
	for (var i = 0; i < _gsNumItems; i++) {
		// Get initial cell.
		tempArray = new Array();
		tempArray.push(_gsItemsArray[i]);

		// Add cloned cell(s).
		for (var k = 1; k < numClones; k++) {
			tempArray.push(_gsItemsArray[i].clone(i));
		}

		// Push all copies of cell into array and repeat.
		_gsCells.push(tempArray);
	}
}

/**
 * This function sets the OUT positions for both the cells and their arrows. It also allows
 * you to set the type of easing that will be used by the cells when animating between IN and
 * OUT states.
 * Note: This must be called before calling animateIn.
 *
 * @param containerOutPos				The cells' OUT positions.
 * @param arrowsOutPos					The arrows' OUT positions.
 * @param containerAnimateInEasing		The easing used by the cells during animating IN and OUT.
 */
gSlider.prototype.setAnimateOutPositions = function(containerOutPos, arrowsOutPos, containerAnimateInEasing) {
	_gsOutPositions 				= containerOutPos;
	_gsArrowOutPositions			= arrowsOutPos;
	_gsContainerAnimateInEasing 	= containerAnimateInEasing;
}

/**
 * This function performs the IN animations for the scroller.
 * Note: You should have called setAnimateOutPositions before calling this function otherwise it will just call show.
 * 		 If arrowDuration and arrowDelay are BOTH set to -1 the arrows will not animateIn and can be done manually.
 *
 * @param containerDuration		The duration that each of the containers animate IN for.
 * @param delay					The delay of the whole animation in.
 * @param incrementalDelay		The incremental delay for the containers.
 * @param arrowDuration			The duration that each of the arrows animate IN for.
 * @param arrowDelay 			The delay before the arrows animation.
 */
gSlider.prototype.animateIn = function(containerDuration, delay, incrementalDelay, arrowDuration, arrowDelay) {
	// If you have not called setAnimateOutPositions or your _outPositions array is null then this function will just call show.
	if (_gsOutPositions == null) {
		_gsSlider.show();
	} else {
		// CONTAINERS
		// Gets each container and sets its' OUT positions.
		for (var k in _gsCellContainerArray) {
			// Loops through the cell's position properties.
			for (var prop in _gsOutPositions[0]) {
				// If property is for top or left position, set each container in a row/column after offsetting them by the out position value.
				if (prop == 'top' || prop == 'left') {
					_gsCellContainerArray[k].style[prop] = _gsHorizontal ? (parseInt(_gsOutPositions[0][prop]) + (_gsSingleContainerWidth * k) + 'px') : (parseInt(_gsOutPositions[0][prop]) + (_gsSingleContainerHeight * k) + 'px');
				}
				else{
					_gsCellContainerArray[k].style[prop] =  _gsOutPositions[0][prop];
				}
			}
		}

		// Keeps track of the duration of each of the animate ins (containers and arrows) to know when to call scrollerReady.
		var animationDuration1  = 0;
		var animationDuration2 	= 0;

		// Animates the cells to their IN position.
		animationDuration1 = _gsSlider.animateContainersIn(containerDuration, delay, incrementalDelay);

		// ARROWS
		if (_gsAnimate && _gsPrevArrow != null && _gsNextArrow != null) {
			// Sets all the properties for the PREVIOUS arrow to their OUT state.
			for (var prevProp in _gsArrowOutPositions[0]) {
				_gsPrevArrow.dom.style[prevProp] = _gsArrowOutPositions[0][prevProp];
			}

			// Sets all the properties for the NEXT arrow to their OUT state.
			for (var nextProp in _gsArrowOutPositions[1]) {
				_gsNextArrow.dom.style[nextProp] = _gsArrowOutPositions[1][nextProp];
			}

			// Animates the arrows into their IN position.
			if (arrowDuration != -1 && arrowDelay != -1) {
				animationDuration2 = _gsSlider.animateArrowsIn(arrowDuration, arrowDelay);
			}
		}

		// Determines how long it should wait until calling scrollerReady (The longer of containers or arrows animating in).
		if (animationDuration1 < animationDuration2) {
			setTimeout( function() {
				_gsSlider.scrollerReady();
			}, animationDuration2 + 500);
		} else {
			setTimeout( function() {
				_gsSlider.scrollerReady();
			}, animationDuration1 + 500);
		}
	}
}

/**
 * This function will animate OUT both the containers and the arrows to their OUT state.
 *
 * @param containerDuration		The duration that each of the containers animate OUT for.
 * @param containerDelay		The delay of the container animation out.
 * @param incrementalDelay		The incremental delay for the containers.
 * @param arrowDuration			The duration that each of the arrows animate OUT for.
 * @param arrowDelay 			The delay before the arrows animation.
 *
 */
gSlider.prototype.animateOut = function(containerDuration, containerDelay, incrementalDelay, arrowDuration, arrowDelay) {
	_gsSlider.removeListeners();

	_gsSlider.terminateAutoScroll();

	_gsSlider.animateContainersOut(containerDuration, containerDelay, incrementalDelay);

	_gsSlider.animateArrowsOut(arrowDuration, arrowDelay);
}

/**
 * This function will animate the arrows to their IN state.
 *
 * @param duration		The duraction of the animation.
 * @param delay 		The delay for the animation.
 *
 * @return 				Returns the total duration including the duration and delay.
 */
gSlider.prototype.animateArrowsIn = function(duration, delay) {
	if (_gsNextArrow == null || _gsPrevArrow == null) {
		return -1;
	}

	// Performs the animation.
	setTimeout( function() {
		// Kill any current animations on the elements we want to animate.
	    killer.kill(_gsPrevArrow.dom.getAttribute('Name'));
	    killer.kill(_gsNextArrow.dom.getAttribute('Name'));

	    // Makes the arrows visible.
		_gsPrevArrow.dom.style.visibility	= 'visible';
		_gsNextArrow.dom.style.visibility	= 'visible';

		new timeAnimation(_gsPrevArrow.dom, _gsArrowPositions[0], duration);
		new timeAnimation(_gsNextArrow.dom, _gsArrowPositions[1], duration);
	}, delay);

	return duration + delay;
}

/**
 * This function will animate the arrows to their OUT positions.
 *
 * @param duration		The duraction of the animation.
 * @param delay 		The delay for the animation.
 */

gSlider.prototype.animateArrowsOut = function(duration, delay) {
	if (_gsNextArrow == null || _gsPrevArrow == null) {
		return;
	}

	// Performs the animation.
	setTimeout( function() {
		// Kill any current animations on the elements we want to animate.
	    killer.kill(_gsPrevArrow.dom.getAttribute('Name'));
	    killer.kill(_gsNextArrow.dom.getAttribute('Name'));

		new timeAnimation(_gsPrevArrow.dom, _gsArrowOutPositions[0], duration);
		new timeAnimation(_gsNextArrow.dom, _gsArrowOutPositions[1], duration);

		// Make the arrows invisible after their animate out is finished.
		setTimeout( function() {
			_gsPrevArrow.dom.style.visibility	= 'hidden';
			_gsNextArrow.dom.style.visibility	= 'hidden';
		}, duration);
	}, delay);
}

/**
 * This function will animate the containers into their IN positions.
 *
 * @param duration				The duration of each animation.
 * @param delay					The delay of each animation.
 * @param incrementalDelay		Increments the delay for a unique feel.
 *
 * @return 						The animation + delay + incremental delay.
 */
gSlider.prototype.animateContainersIn = function(duration, delay, incrementalDelay) {
	// Set a timeout to wait for the initial delay.
	setTimeout( function() {
		// Loops through all of the containers.
		for (var k = 0; k < _gsCellContainerArray.length; k++) {
			// Sets up time outs with closure that will animate each container in.
			_gsSlider.setTimeOutWithClosure(k, duration, incrementalDelay, true);
		}
	}, delay);


	return delay + duration + (incrementalDelay * (_gsCellContainerArray.length - 1));
}

/**
 * This function will animate the containers into their OUT positions.
 *
 * @param duration				The duration of each animation.
 * @param delay					The delay of each container animation.
 * @param incrementalDelay		Increments the delay for a unique feel.
 *
 */
gSlider.prototype.animateContainersOut = function(duration, delay, incrementalDelay) {
	// Set a timeout to wait for the initial delay.
	setTimeout( function() {
		// Loops through all of the containers.
		for (var k = 0; k < _gsCellContainerArray.length; k++) {
			// Sets up time outs with closure that will animate each container in.
			_gsSlider.setTimeOutWithClosure(k, duration, incrementalDelay, false);
		}
	}, delay);
}

/**
 * This function is used to animate the containers in one by one
 * using the incremental delay. It will set up a time out with
 * closure so that the loop it is called from uses the correct value.
 *
 * @param containerNumber		The container number that will be animated in.
 * @param duration				The duration that each animation will last.
 * @param incrementalDelay		The additional delay between each animation.
 * @param animateIn				Whether or not the containers are animating in.
 */
gSlider.prototype.setTimeOutWithClosure = function(containerNumber, duration, incrementalDelay, animateIn){
	// If animating in containers will animate from first to last. If animating out containers will animate from last to first.
	var delay = animateIn ? (incrementalDelay * containerNumber) : ((_gsCellContainerArray.length - 1) * incrementalDelay) - (incrementalDelay * containerNumber);

	// Set up each timeout based upon the incremental delay.
	setTimeout(function() {
		// Call function to animate each individual container in or out.
		if (animateIn) {
			_gsSlider.animateContainerIn(containerNumber, duration);
		}
		else {
			_gsSlider.animateContainerOut(containerNumber, duration);
		}
	}, delay);
}

/**
 * This function is used to animate an individual container in.
 *
 * @param containerNumber		The container number that will be animated in.
 * @param duration				The duration that each animation will last.
 */
gSlider.prototype.animateContainerIn = function(containerNumber, duration){
	// Clones the positions so that they can be modified without effecting the originals.
	var inCellPos 		= _gsSlider.clonePosition(_gsPositions[containerNumber]);
	inCellPos.EASING 	= _gsContainerAnimateInEasing;

	// Kill any current animations on the elements we want to animate.
    killer.kill(_gsCellContainerArray[containerNumber].getAttribute('Name'));

	// Make the container visible.
	_gsCellContainerArray[containerNumber].style.visibility = 'visible';

	// Performs animation.
	new timeAnimation(_gsCellContainerArray[containerNumber], inCellPos, duration);
}

/**
 * This function is used to animate an individual container out.
 *
 * @param containerNumber		The container number that will be animated out.
 * @param duration				The duration that each animation will last.
 */
gSlider.prototype.animateContainerOut = function(containerNumber, duration){
	// Kill any current animations on the elements we want to animate.
    killer.kill(_gsCellContainerArray[containerNumber].getAttribute('Name'));

	// Performs animation.
	new timeAnimation(_gsCellContainerArray[containerNumber], _gsOutPositions[0], duration);

	// Make the container invisible after it's animate out is finished.
	setTimeout(function(){
		_gsCellContainerArray[containerNumber].style.visibility = 'hidden';
	}, duration);
}

/**
 * This function is called if you would like the scroller to appear immediately instead of
 * animating it in. This allows you to do some general animations outside of this scroller.
 */
gSlider.prototype.show = function() {
	// Loops through cells setting their visibility to true and animating in the containers.
	for (var k = 0; k < _gsCellContainerArray.length; k++) {
		if (_gsCellContainerArray[k] != null) {
			_gsCellContainerArray[k].style.visibility 	= 'visible';
		}
	}

	// Will make the arrows visible if there will be scrolling.
	if (_gsAnimate && _gsPrevArrow != null && _gsNextArrow != null) {
		_gsPrevArrow.dom.style.visibility 				= 'visible';
		_gsNextArrow.dom.style.visibility 				= 'visible';
	}

	_gsSlider.scrollerReady();
}

/**
 * This function is called when the scroller is ready. Its purpose is to start the auto scrolling
 * if it has been defined as well as add the event listeners for the scroller. It also dispatches
 * an event to tell that the animate IN process is over.
 */
gSlider.prototype.scrollerReady = function() {
	// Determines if it should start the auto scrolling.
	if (_gsAnimate) {
		_gsSlider.setupAnimationTermination();
	}

	// Adds the click listeners for arrows and cells.
	_gsSlider.addListeners();
}

/**
 * This function is called once the scroller is animated IN and listens for when the
 * animationDelay ends so it can terminate auto scrolling.
 */

gSlider.prototype.setupAnimationTermination = function() {
	if (SSM_ad_obj.AnimationDelay > 0 && _gsAutoScrollForce) {
		setTimeout(function(){
			_gsSlider.terminateAutoScroll();

		}, SSM_ad_obj.AnimationDelay * 1000)
	}
}


/**
 * This function determines the rate the slider should move by.
 */
gSlider.prototype.moveCellBy = function() {
// _gsScrollState is determined by mouseEvents and animationDelay.
// _gsScrolling is used to avoid interupting a manual scroll when terminateAutoScroll is called.
	if (_gsScrollState == "auto") {
		return -(_gsAutoScrollRate);
	}
	else if (_gsScrollState == "upLeft" || _gsScrolling == "upLeft") {
		return _gsHoverScrollRate;
	}
	else if (_gsScrollState == "downRight" || _gsScrolling == "downRight") {
		return -(_gsHoverScrollRate);
	}
	else {
		return 0;
	}
}

/**
 * This function determines the rate and direction the slider should move.
 *
 * @param e			ENTER_FRAME event.
 */
gSlider.prototype.scrollerMovement = function() {
	// Get scrolling rate.
	var moveCell = _gsSlider.moveCellBy();

	// If the rate is not 0, proceed.
	if (moveCell != 0) {
		if (!_gsHorizontal) {
			// Move each container by specified rate.
			for (var k = 0; k < _gsCellContainerArray.length; k++) {
				_gsCellContainerArray[k].style.top = (parseInt(_gsCellContainerArray[k].style.top) + moveCell) + 'px';
			}

			// Check if the extra container needs to move to the top for continuous scrolling depending on it's position. Containers scrolling top to bottom.
			if ((parseInt(_gsCellContainerArray[_gsEndUnit].style.top) > _gsSliderHeight) && (_gsScrolling == 'upLeft')) {
				_gsCellContainerArray[_gsEndUnit].style.top = (parseInt(_gsCellContainerArray[_gsEndUnit].style.top) - _gsAllContainersHeight - _gsCellPadding) + 'px';
				_gsStartUnit = _gsEndUnit;

				if (_gsEndUnit == 0) {
					_gsEndUnit = _gsCellContainerArray.length - 1;
				} else {
					_gsEndUnit--;
				}
			}

			// Check if the extra container needs to move to the bottom for continuous scrolling depending on it's position. Containers scrolling bottom to top.
			if ((parseInt(_gsCellContainerArray[_gsStartUnit].style.top) < 0 - _gsSingleContainerHeight) && ((_gsScrolling == 'downRight') || (_gsScrollState == 'auto'))) {
				_gsCellContainerArray[_gsStartUnit].style.top = (parseInt(_gsCellContainerArray[_gsStartUnit].style.top) + _gsAllContainersHeight + _gsCellPadding) + 'px';

				_gsEndUnit = _gsStartUnit;

				if (_gsStartUnit == _gsCellContainerArray.length - 1) {
					_gsStartUnit = 0;
				} else {
					_gsStartUnit++;
				}
			}
		}
		else if (_gsHorizontal) {
			// Move each container by specified rate.
			for (var i = 0; i < _gsCellContainerArray.length; i++) {
				_gsCellContainerArray[i].style.left = (parseInt(_gsCellContainerArray[i].style.left) + moveCell) + 'px';
			}

			// Check if the extra container needs to move to the left for continuous scrolling depending on it's position. Containers scrolling left to right.
			if ((parseInt(_gsCellContainerArray[_gsEndUnit].style.left) > _gsSliderWidth) && (_gsScrolling == 'upLeft')) {

				_gsCellContainerArray[_gsEndUnit].style.left = (parseInt(_gsCellContainerArray[_gsEndUnit].style.left) - _gsAllContainersWidth - _gsCellPadding) + 'px';
				_gsStartUnit = _gsEndUnit;

				if (_gsEndUnit == 0)	{
					_gsEndUnit = _gsCellContainerArray.length - 1;
				} else {
					_gsEndUnit--;
				}
			}

			// Check if the extra container needs to move to the right for continuous scrolling depending on it's position. Containers scrolling right to left.
			if ((parseInt(_gsCellContainerArray[_gsStartUnit].style.left) < 0 - _gsSingleContainerWidth) && ((_gsScrolling == 'downRight') || (_gsScrollState == 'auto')))	{

				_gsCellContainerArray[_gsStartUnit].style.left = (parseInt(_gsCellContainerArray[_gsStartUnit].style.left) + _gsAllContainersWidth + _gsCellPadding) + 'px';
				_gsEndUnit = _gsStartUnit;

				if (_gsStartUnit == _gsCellContainerArray.length - 1) {
					_gsStartUnit = 0;
				} else {
					_gsStartUnit++;
				}
			}
		}
	}
}

/**
 * This function is called to terminate auto scrolling when the animationDelay is up.
 * Note: Auto scrolling will not resume again once this has been called.
 */
gSlider.prototype.terminateAutoScroll = function() {
	_gsAnimate 		= false;
	_gsScrollState 	= 'terminated';
}

/**
 * This function will add the listeners for the stage and arrow hovers.
 * It will also start the auto scrolling.
 *
 * Note: This will not affect listeners that were added to the objects outside of this
 * scroller class.
 */
gSlider.prototype.addListeners = function() {
	if (_gsAnimate) {
		_gsAutoScroll = setInterval(_gsSlider.scrollerMovement, Math.floor(1000/_gsFps));

		// Using jQuery event library until we develop an internal one.
		$('#ssm_ad_container').bind("mouseover.mouseOverManager", function(event) {
            _gsSlider.mouseOverManager(event);
        });

        $('#ssm_ad_container').bind("mouseout.mouseOutManager", function(event) {
            _gsSlider.mouseOutManager(event);
        });
	}
}

/**
 * This function will remove the listeners for the stage and arrow hovers.
 * It will also stop the auto scrolling.
 *
 * Note: This will not affect listeners that were added to the objects outside of this
 * scroller class.
 */
gSlider.prototype.removeListeners = function() {
	if (_gsAnimate) {
		clearInterval(_gsAutoScroll);

		// Using jQuery event library until we develop an internal one.
		$('#ssm_ad_container').unbind("mouseover.mouseOverManager");

        $('#ssm_ad_container').unbind("mouseout.mouseOutManager");
	}
}

/**
 * This function will handle the mouseOver events for the arrows and stage
 * which dictate how the scroller should behave.
 */
gSlider.prototype.mouseOverManager = function(event) {
	var target = (event.target) ? event.target : event.srcElement;

	// If the target is null it means the upper most parent has been reached.
	while (target != null) {
		// If 'stage' is the target on:
		if (target === id('ssm_ad_container') && _gsAutoScrollMousePause) {
			// Pause scrolling.
			_gsScrollState 			= "pause";

			// Reset _gsScrolling variable as no arrow is being hovered on.
			_gsScrolling 			= '';

			return;
		}
		// If prev arrow is the target on:
		else if (_gsPrevArrow != null && target === _gsPrevArrow.dom) {
			// Set variables to scroll up/left.
			_gsScrollState 			= "upLeft";

			_gsScrolling 			= "upLeft";

			return;

		}
		// If next arrow is the target on:
		else if (_gsNextArrow != null && target === _gsNextArrow.dom) {
			// Set variables to scroll down/right.
			_gsScrollState 			= "downRight";

			_gsScrolling 			= "downRight";

			return;
		}

		// Increments up through its parents.
		target = parent(target);
	}
}

/**
 * This function will handle the mouseOut events for the arrows and stage
 * which dictate how the scroller should behave.
 */
gSlider.prototype.mouseOutManager = function(event) {
	var target = (event.target) ? event.target : event.srcElement;

	// If the target is null it means the upper most parent has been reached.
	while (target != null) {
		// If 'stage' or either arrow is hovered off:
		if ((target === id('ssm_ad_container') && _gsAutoScrollMousePause) || (_gsPrevArrow != null && target === _gsPrevArrow.dom) || (_gsNextArrow != null && target === _gsNextArrow.dom)) {
			// Start auto scrolling again if animationDelay has not ended yet.
			if (_gsAnimate) {
				_gsScrollState 		= "auto";
			}
			else {
				_gsScrollState 		= "terminated";
			}

			// Reset _gsScrolling variable as no arrow is being hovered on.
			_gsScrolling 			= "";

			return;
		}

		// Increments up through its parents.
		target = parent(target);
	}
}

/**
 * This function will take in a object that contains all the positions data and
 * it will clone it and return an exact replica.
 *
 * @param pos	The positions object that will be copied.
 *
 * @return 		The copied positions object.
 */
gSlider.prototype.clonePosition = function(pos) {
	var newPos = new Object();

	// Cycles through all of the available properties.
	for (var k in pos) {
		newPos[k] = pos[k];
	}

	return newPos;
}

/**
 * This function sets the X (left) position of the scroller.
 */
gSlider.prototype.x = function(left) {
    byClass('scroller')[0].style.left = left;
}

/**
 * This function sets the Y (top) position of the scroller.
 */
gSlider.prototype.y = function(top) {
    byClass('scroller')[0].style.top = top;
}